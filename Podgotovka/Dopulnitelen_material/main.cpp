#include <iostream>
using namespace std;

#if 0 // START Променливи

// 1

// Променливи не могат да бъдат със същото
// име като ключовите думи в езика
int break = 2017;
cout << break;

// 2

// Имената на променливите не могат да започват
// с цифри
long int 2017b = 1234;
cout << 2017b;

// 3
// Валиден запис, промелнива може да започва с долна черта
void underscore()
{
	int _ = 2000;
	int __ = 17;
	int ___;
	___ = _ + __;
	cout << ___;
}

// 4
// Невалиден запис - в записа не може да се
// съдържат други символи освен букви от латинската азбука,
// цифри и долна черта
int get-avg(int max-val, int min-val)
{
	return (max-val + min-val) / 2;
}

// 5
// Не може да има променливи
// с едно и също име в един блок
void locScope()
{
	int xyz = 20;
	int xyz;
}

// 6
// Локалните променливи/имена скриват глобалните
int x = 41;
int giveX()
{
	int x = 123;
	{
		return x; // Функцията ще върне като резултат 123, защото х дефиниран 
		          // в блокът на фунцкията скрива глобалната променлива със стойност 41
	}
}

// 7
int giveX2()
{
	int x = 123;
	{
		extern int x;
		return x; // Тук функцията ще ни върне 41, защото със 'extern int x' сме казали на компилатора, че има 
		          // външна променлива с това име, която не е дефинирана в блокът на функцията
		          // и линкерът ще я търси в друг блок(спокойно може да закоментираме  'int x = 123')
	}
}

// 8
void caseSensitive()
{
	int VAR = 10;	   // Променливите в С/С++ са чувствителни към малките и големите букви
	printf("%d", var); //  VAR и var са две различни имена
}

// 9
#include <stdio.h>
void mac()
{
	// Тук EOF макрос дефиниран в stdio.h по следният начин
	// #define EOF     (-1)
	int EOF = 123; // Това означава, че след като мине предпроцесора
	               // 'int EOF = 123;' ще изглежда по следният начин => int (-1) = 123
	               // Ще получим компилационна грешка, защото левият операнд на оператора '='
	               // трябва да бъде стойност на която може да променим стойността (lvalue)
}

// 10
int main()
{
	int main = 2017;
	cout << main; // Тук локалната променлива 'int main' скрива
			      // по-глобалното име (функцията int main())
	main();       // Поради тази причина и не можем да извикаме
	              // функцията main() (да, можем да извикаме рекурсивно main функцията)
	              // защото в този блок тя е целочислена променлива
	return 0;
}

// 11
void printSizes()
{
	double dDouble = 2.0;
	int  nInteger = 5;
	cout << sizeof(!dDouble) << endl; // Отрицанието на число е израз от булев тип => 1 байт
	cout << sizeof(15 / dDouble) << endl; // Правилото, когато се извършват операции между променливи с различен
	                                      // тип е, че изразът се преобразува до по-големият от двата типа - в случаят
	                                      // '15 / dDouble' се преобразува до тип double => 8 байта
	cout << sizeof(nInteger = 15 / dDouble) << endl; // '15 / dDouble' се преобразува до тип double
	                                                 // след което се преобразува до типа на nInteger: 
                                                     // int => 4 байта (типичен пример за загуба на точност)
	 
}

// 12
int gnInteger;
void static1()
{
	int a;
	cout << a << endl; // На VC2013 дава компилационна грешка, употреба на неинициализирана променлива

	static int b; // Статичните и глоблните се инициализират винаги със стойност  по подразбиране
	              // (за int и като цяло вградените типове стойността е нула), ако изрично не им дадем стойност
	cout << b << endl; // Изпечатва 0

	cout << gnInteger << endl; // Също изпечатва 0
}

// 13
void defaultType()
{
	// В зависимост от компилатора е позволено да изпуснем
	// типа на променливата, той приема че типът по подразбиране е int
	short a = 10;
	static b = 10;
	unsigned c = 10;
	const d = 10;
}

// 14
void expRes()
{
	long double a;
	signed char b;
	int arr[sizeof(!a + b)]; // Резултата от събирането на булев израз (!a) + символ (b) е цяло число => 4 байта
	cout << sizeof(arr); // => 16 байта
	cout << typeid(!a + b).name(); // Ако се чудим за типа на даден израз може да използваме операторът typeid
}

// 15
void manyPluses()
{
	int x = 0;
	int z = x+++1; // Този израз се интерпретира по следният начин: (x++)+1 => z = 1
	               // х++ - извлечи и увеличи
	               // ++х - увеличи и извлечи

	int n = 1;
	z = x++++++n; // Този израз се интерпретира по следният начин: ((x++)++)+1 => z = 1
	              // (x++) връща като резултат временна променлива (това е и причината в горният пример z да има стойност 1)
	              // на която не може да вземем адреса (rvalue) и върху нея не можем да извършим операцията ++
}



#endif // END Променливи


#if 0 // START Условни оператори

// 1
void comp1()
{
	float a = 0.7; // 0.7 се присвоя на променлива от тип float и се представя в памета като следното число: 0.699999988
	if (a<0.7){ // 0.7 е тип double и се представя в памета като следното число: 0.69999999999999996
		        // 0.7f < 0.7 се оценява като истина
		printf("a < 0.7");
	}
	else{
		printf("a > 0.7 || a == 0.7");
	}
}
void comp2()
{
	float a = 0.7;
	if (a < 0.7f){ // Правилен начин да сравним тези числа
		printf("a < 0.7");
	}
	else{
		printf("a > 0.7 || a == 0.7");
	}
}

// 2
void makeSelection()
{

	unsigned char c = 250;
	switch (c)
	{
		cout << "Start\n"; // Парче код, което няма да се изпълни никога
		case 250:
		{
			cout << "case 250\n"; // Забравили сме break
		}
		case 249:
		{
			cout << "case 249\n"; // Тук също
		}
		default:
		{
			cout << "default case\n"; // И тук също, освен ако не искаме да се изпълни 
			                          // кодът отдолу
		}
			cout << "End\n";
	}
}

// 3
void zeroSwitch()
{
	// В switch-case конструкция не може да имаме дублиращи се случаи
	switch (0X0)
	{
		case NULL: // NULL е дефиниран по следният начин => '#define NULL  0'
		{
			cout << "VW Passat\n";
			break;
		}
		case '\0': // Друг запис за нула
		{
			cout << "VW Golf\n";
			break;
		}
		case 0: // Нормален запис на нула
		{
			cout << "VW Jetta\n";
			break;
		}
		case 00: // Още един начин да запишем нулата
		{
			cout << "VW Scirocco\n";
			break;
		}
		default: 
		{
			cout << "VW Polo\n";
		}
	}
}

// 4
void allMenMustDie()
{
	int a = 256;
	if (a > 255 && ++a) // a > 255 е вярно, след което се проверява изразът отдясно => ++a = 257, различно
		                // от нула => оценява се като истина и съобщението се изпечатва
	{
		cout << "Valar morghulis\n";
	}
}

// 5
void allMenMustObey()
{
	int b = 16;
	if (b > 16 || b++) // b > 16 не е вярно, което значи, че изразът отдясно трябва да се оцени. Той се оценя като истина(b++ - извлечи = 16 и после увеличи),
                       // b се увеличива с 1 и съобщението ще се изпечата
	{
		cout << "Valar dohaeris\n";
	}
}

// 6
void starks()
{
	int d = 512;
	if (d > 512 && ++d) // d > 512 не е вярно, което значи че изразът отдясно няма да се оцени и съобщението няма да се изпечата
	{
		cout << "King of the north\n";
	}
}

// 7
void sayStarkWords()
{
	int c = 0;
	if (c >= 0 && c++) // c >= 0 е вярно, което значи, че изразът отдясно има смисъл да се оцени. Той се оценя като лъжа (c++ извлечи(=0) и увеличи) => съобщението няма да се изпечата
	{
		cout << "Winter is coming\n";
	}
}

// 8
void khaleesi()
{
	int e = 1024;
	if (e = !512 ? 1024 : !(256 - 2 * 16 * 8)) // Изразът се оценява по следният начин:
                                               // 1. e = !512: !512 се оценява като лъжа => е има стойност 0
											   //    следователно влизаме във случаят на false
                                               // 2. !(256 - 2 * 16 * 8): 256 - 2 * 16 * 8 = 0 => !(0) се оценя като истина и съобшението се изпечатва
	{
		cout << "Where are my dragons ???\n";
	}
}

// 9
void selectValue()
{
	int x;
	x = 10, 20, 30; // Изразът '10, 20, 30' се оценява по следният начин: (10, 20) => (20, 30) => 30, но понеже
	                // операторът за присвояване '=' е с по-висок приоритет спрямо оператора ','
	                // първо се изпълнява присвоянването и след това се оценява изразът '10, 20, 30'
	cout << "The value of x is : " << x << endl; // Изпечатва се 10
	x = (10, 20, 30); // Тук вдигаме приоритета на изразът '10, 20, 30' и операторът ',' се изпълнява преди присвояването
	cout << "The value of x is : " << x << endl; // Изпечатва се 30
}

#endif // END Условни оператори

#if 0 // START Цикли

// 1
void toDoOrNotToDo()
{
	int i = 0;
	do
	{
		cout << i;
		i++;
	} while (5, 4, 3, 2, 1, 0); // Изразът '5, 4, 3, 2, 1, 0' се оценява по следният начин:
	                            // (5, 4) => (4, 3) => (3, 2) => (2, 1) => (1, 0) => 0
                                // Цикълът ще се завърти веднъж, стойността на i ще бъде 1
}

// 2
void octRange()
{
	for (int i = 0; i < 011; i++) // Тук цикълът няма да се завърти 11 пъти, а 9 защото '011' е запис
                                  // на число в осмична бройна система.
	{
		cout << i << endl;
	}
}

// 3
void printer()
{
	int i, j;
	i = j = 2, 3; // Тук въпросът е кой от операторите '=' и ','
	              // е с по-висок приоритет. Оперататорът '=' е с по-висок
				  // приоритет и изразът ще се оцени по следният начин '((i = (j = 2)), 3)'
                  // 1. Операторът '=' е дясно асоциативен, което значи че първото нещо
                  //    което ще се изпълни е 'j = 2'
                  // 2. Резултата от изпълнението на 'j = 2' е 2 и тази стойност ще се присвои на i
                  // 3. Резултата от изпълнението на 'i = 2' e 2 и тази стойност ще се зе използва
                  //    да се извика операторът ',' - '2, 3' , резулата от който ще бъде 3
   				  //   cout << (i = j = 2, 3) - какво би изпечатало това ?
	
	while (--i&&j++)            // На първата итерацаия изразът ще се оцени по следният начин:
		cout << i << j << endl; //     --i => 1, стойността на i е вече 1 => има смисъл да проверим изразът отдясно
}                               //     j++ => 2, стойността на j е вече 3 => изразът се оценява като истина
                                //     изпечатва се 13
								// На втората итерацаия изразът ще се оцени по следният начин:
                                //      --i => 0, стойността на i е вече 0 => няма смисъл да проверим изразът отдясно,
								//      изразът се оценява като лъжа

// 4
void minusRange()
{
	                            // Поредността от действия при изпълнението на for цикълът е следната:
                                // 'for(инициализираща-част; условие; корекция) оператори', където:
                                // 1. 'инициализираща-част' се извиква точно веднъж, при първото извикване на операторът
                                // 2. 'условие' се извиква преди всяко изпълнение на операторите предвидини за изпълнение от for
								//     Ако 'условие' се оцени като истина ще се изпълнят операторите след for, ако се оценит като
								//     лъжа ще се прекрати изпълнието на цикъла 
								// 3. Изпълняват се операторите операторите предвидини за изпълнение от for
								// 4. Изпълняват се операторите в секцията 'корекция', след което се връщаме към точка 2
	int i;
	for (i = -5; i = 5; i = -5) // 1. На първата стъпка('инициализираща-част'), на i се задава стойност -5
	{                           // 2. На втората стъпка('условие'), на i се задава стойност -5, това се оценява като истина
		cout << i << endl;      // 3. Изпълняват се операторите в блока => прекратява се изпълнението на цикълът(i е равно на 5)
		if (i != -5) break;
	}
}

// 5
void print5Times()
{
	for (int i = 0; i <= 5; i++); // Тук ще имаме компилационна грешка, защото i е локална променлива: цикълът for се прекратява
		cout << i << endl;        //  още на първият ред заради точката и запетайката точно след него (цикълът не прави нищо)
}


// 6
int val(){
	int static num = 10; // Променливата num се инициализира точно веднъж, при пъврото извикване на функцията(има малко повече детайли относно
	return num--;        // инициализацията на статичните промнливи, но не са важни тук)
}

void staticValues()
{
	//    1      2       3
	for (val(); val(); val()) // За улеснение ще означим всяка от стъпките с числа. Изпълнението на този фрагмент ще протече по следният начин:-
	{   //       4            // 1:  val() се изква от място 1 => като резултат се връща 10, стойността на num е 9
		cout << val();        // 2:  val() се изква от място 2 => като резултат се връща 9, стойността на num е 8
	}                         // 3:  val() се изква от място 4 => като резултат се връща 8, стойността на num е 7
}                             // 4:  val() се изква от място 3 => като резултат се връща 7, стойността на num е 6
                              // 5:  val() се изква от място 2 => като резултат се връща 6, стойността на num е 5
                              // 6:  val() се изква от място 4 => като резултат се връща 5, стойността на num е 4
                              // 7:  val() се изква от място 3 => като резултат се връща 4, стойността на num е 3
                              // 8:  val() се изква от място 2 => като резултат се връща 3, стойността на num е 4
                              // 9:  val() се изква от място 4 => като резултат се връща 2, стойността на num е 1
                              // 10: val() се изква от място 3 => като резултат се връща 1, стойността на num е 0
                              // 11: val() се изква от място 2 => като резултат се връща 0, стойността на num е -1

// 7
void drinkBeer()
{
	bool sober = false;
	unsigned char beer = 0;
	while (sober) // sober е равно на false => няма да изпием нито една бира (не сме много доволни)
	{
		beer++;
	}
}

void drinkBeer2()
{
	bool sober = false;
	unsigned char beer = 0;
	do
	{
		beer++;
	} while (sober); // Тук отново не сме трезви, но понеже сме използвали do while конструкция
}                    // сме сигурни, че ще изпием поне една бира(малко по-доволни сме, но не достатъчно)

void drinkBeer3()
{
	bool sober = true;
	unsigned char beer = 0;
	while (sober) // Тук вече сме трезви и ще пием бира неграничено много(е не повече от 255 де)
	{             // или ще внимаваме, когато бирите ни дойдат в повече да преценим, че не сме трезви вече
		beer++;
	}
}

// 8
void endlessC++Love() // Тук дали имаме валидно име на функция ?
{
	for (int i = 0, j = 0; j < 20, i < 10; ++i, j += 3) // Тук може да се подлъжем, че проверката ни за прекратяване
	{                                                   // на цикъла ще сработи когато едно от двете условия (j < 20, i < 10)
		cout << "We like C++\n";                        // е изпълнено, но в действителност този израз ще се оцени по следният начин
	}                                                   // Първо ще се проври дали 'j < 20' след което ще се провери дали 'i < 10'
                                                        // и като резултат ще се върне оценяването на i < 10. Това значи, че съобщението
                                                        // ще се изпечата 10 пъти, а не 7
	
	for (int i = 0, j = 0; i < 10, j < 20; ++i) // Тук няма как се подлъжем вече, но сме забравили да увеличаваме
	{                                           // променливата j (а може и да обичаме просто безкрайно много C++)
		cout << "We love C++\n";
	}
}

// 9
void findTheForce()
{
	for (unsigned char i = 0; i < 256; i++)              // Тук проблемът идва от това че променливите от тип unsigned char имат стойности
	{                                                    // в интервалът [0, 255], което значи че дори след като стигнем 255 проверката винаги ще е
		cout << "I find your lack of bits disturbing\n"; // вярна и имаме малко по-скрит безкраен цикъл
	}
}

// 10
void printOdd()
{
	// Print odd numbers in the range [1, 10]
	int number = 1; // Тук нашата задача е да изпечатаме нечетните числа в интервала [1, 10]
	while (number <= 10)
	{
		if (number % 2 == 0) continue; // Тук сме преценили, че когато имаме четно число, не искаме
		cout << number << endl;        // да се изпълнява логиката ни за изпечатване в конзолата, но сме
		number++;                      // забравили да увеличаваме променливата, когато сме четно число - ще изкараме
	}                                  // в конзолата 1, ще увеличим променливата на 2 и ще попаднем в безкраин цикъл. По-логично би
}                                      // било да изпечатваме числото само когато е нечетно и да увеличаваме променливата винаги

// 11
void printEven()
{
	int number = 1;
	// Print even numbers from in the range [1, 5]
	for (;;)                      // Тук имаме подобна задача, но този път сме решили да използваме
	{                             // безкраен цикъл и в момента, в който минем 5 да излезем от него
		if (number > 5);          // Също сме решили да изпечатваме числото, само когато то е четно и да увеличаваме промелнивата
		break;                    // винаги. До тук много добре, но в бързината сме написали една ';' в повече точно след if (number > 5), което
                                  // ще доведе до безусловно изпълнение на операторите под него(цикълът ще приключи още на първата итерация)
		if (number % 2 == 0)
		{
			cout << number << endl;
		}
		number++;
	}
}

// 12
void doPrint()
{
	int i = 0;
	do
	{
		cout << i;
		i++;
	} while (5, 4, 3, 2, 1, 0); // Тук изразът ще се оцени по следният начин: (((((5, 4), 3), 2), 1), 0)
}                               // (5, 4) => (4, 3) => (3, 2) => (2, 1) => (1, 0) => 0
                                // Ще се изпечата веднъж i, ще се увеличи и ще се прекрати изпълнението на цикъла 

// 13
int countLoops()
{
	int counter = 0;
	for (int i = 0; i < 16; i++)
	{
		for (int j = 0; j < 8; j++)
		{
			for (int k = 0; k < 4; k++)
			{
				for (int n = 0; n < 2; n++)
				{
					for (int l = 0; l < 0; l++) // Тук 16 * 8 * 4 * 2 пъти няма да направиш нищо
					{                           // и стойността на counter ще си остане нула
						counter++;
					}
				}
			}
		}
	}
	return counter;
}

#endif // END Цикли

#if 0 // START Масиви

// 1
void strangeIt()
{
	int arr[] = { 1, 2, 3, 4 };
	for (int i = 0; i < 4; i++)
	{
		cout << i[arr] << endl; // Напълно валиден синтаксис - операторът '[]' работи по следният начин:
	}                           // Неговите операнди трябва да са число и адрес (предефиниран е както за указатели, така и за числа)
}                               // и работи така - *(адрес + число)

// 2
void printArrays()
{
	static int arr1[2] = { 1, 2 }; // Зависи от имплементацията/компилатора, къде и как биха били
	static int arr2[2] = { 3, 4 }; // разположени статичните променливи

	for (int i = 0; i < 4; i++)
	{
		cout << arr1[i] << endl;  // На VS 2013, компилатора подрежда статични променливи последователно
	}                             // в паметта и може да достъпим arr2, като използвам адреса на arr1. За gcc 4.9.2
                                  // това не e валидно и променливите не се подредждат по същият начин => имаме недефинирано поведение
	
	int arr3[2] = { 1, 2 }; // Тук отново не може да сме сигурни, как биха били
	int arr4[2] = { 3, 4 }; // разположени променливите на стека

	for (int i = 0; i < 4; i++)
	{
		cout << arr3[i] << endl; // Тук единственото дефинирано поведение е изпечатването на arr3, достъпването на елементи
	}                            // след него води до недефинирано поведение
}                                // Не разчитайте на поведение, което не е дефинирано(особено за преносими платформи). Това са едни
                                 // от най-неприятни проблеми за намиране и отстраняване

// 3
void strangeIdx()
{
	int arr[105] = { 0 };
	cout << arr['c'];   // 'c' е запис на числов литерал в 256-тична бройна система => 'с' == 99 * 256^0 = 99
	cout << arr['c++']; // стойноста на 'c++' е: 99 * 256^2 + 43 * 256^1 + 43 * 256^0 = 6499115
}

// 4
void strangeIdx2()
{
	int i = 0;
	while (putchar(i++["Kude me slojiha??"])); // Напълно валиден синтаксис за обхождане на низови литерали. Причината това
}                                              // да работи е заради типът от който е "Kude me slojiha??" - char const [дължина_на_низа + 1]

// 5
void countOcenki()
{
	int ocenki[10] = { 6, 2, 4, 5, 4, 5, 6, 5, 3, 3 };
	int broiOtlichnici = 0;
	int broiSkusani = 0;
	for (int i = 0; i < 10; i++)
	{
		if (ocenki[i] = 6)     // Проблемът тук е че сме написали оператор за присвояване, вместо за сравнение
		{                      // резултата от който е винаги десният операнд ('6' в случая, различно от нула => истина)
			broiOtlichnici++;  // => изпълняваме опраторите след if-а всеки път
		}
		else if (ocenki[i] = 2)
		{
			broiSkusani++;
		}
	}
	cout << "Broi otlichni studenti: " << broiOtlichnici << endl; // Всички студенти са отличници
	cout << "Broi skusasni studenti: " << broiSkusani << endl; // Нямаме нито един скъсан студент(може би понякога грешките са хубаво нещо)
}

#endif // END Масиви

#if 0 // START Низове

// 1
void readFromConsole()
{
	char str[100] = { 0 }; 
	cin >> str;  // Неправилен начин да четем низове от конзола поради следните причини:
	cout << str; // 1. Четено на низа ще се прекрати до първият символ за интервал, което би могло доведе до следното поведение
                 //     1.1 Нека имаме следният фрагмент
				 //     {
				 //        	char str[100];
	             //         char str2[100];
	             //         cin >> str;
	             //         cin >> str2;
	             //         cout << str << endl;
	             //         cout << str2 << endl;
				 //     }
				 //
				 //     Примерен вход: "VW Passat"
				 //     Изход: "VW"
				 //            "Passat"
				 //     Какво се случва тук: Прочита се низ до първият символ за интервал, след което ако изпълнението на програмата
				 //     очаква други входни данни от конзолата се предават на другите cin обекти, ако никой не очаква входни данни, се губят . 
				 //     и продължава изпълнението на програмата. В примера по-горе имаме късмет, че след това четем отново низ, но ако беше
				 //     число или променлива от друг тип, щяхме да получим неочаквано(освен ако не целим точно това разбира се) поведение.
				 // 2. По този начин нямаме проверка за размерите на низа в който пишем и лесно можем да пишем извън неговите размери, което
                 //    ще доведе до недефинирано поведение		 
	char str[100] = { 0 };
	cin.getline(str, 100); // Правилен начин за четене на низове от конзолата, всички проблеми описани по-горе не съществуват
	cout << str;
}

// 2
void print()
{
	char *ptr = "We love C++";
	cout << -3[ptr] << endl; // Напълно валиден синтаксис, тук събираме числото 3 с адреса на ptr след което 
}                            // взимаме числовата му стойност ('l' в ASCII талицата е с номер 107) и прилагаме
                             // оператора '-' върху него: -(3[ptr]) => -107
// 3
// Каква е разликата между двата записа
1. char* ptr   = "Hello world"; // "Hello world" e от тип char [дължина_на_низа + 1] и е статична променлива
                                // заделена в специална памет в програмата, ptr сочи към тази памет. 
								// Промяна на тази памет чрез ptr води до недефинирано поведение(най-често прекратяване на програмата)
2. char ptr[]  = "Hello world"; // Тук отново "Hello world" e от тип char [дължина_на_низа + 1] и е статична променлива заделена в 
                                // специална памет в програмата. Тук различното е че ptr е масив с размер дължина_на_низа + 1 
								// (изчислява се по време на компилация) и се прави копие на "Hello world" в ptr и вече може спокойно
								// може да променямае данните в ptr

#endif // END Низове

#if 0 // START Указатели и псевдоними
// 1
void ref()
{
	int a = 5;
	int&b = a;
	b = 10;
	cout << a;
}

// 2
void foo(int* a)
{
	static int b = 4;
	a = &b;
}

void bar(int** a)
{
	static int b = 4;
	*a = &b;
}

void ptrsTest()
{
	int* ptr1 = NULL;
	foo(ptr1);
	cout << *ptr1;
	
	int* ptr2 = NULL;
	bar(&ptr2);
	cout << *ptr2;
}

// 3
int chunky()
{
	int a = 0;
	return a++;
}

int bacon()
{
	static int a = 0;
	return a++;
}

void chunkyBacon()
{
	for(int i = 0; i < 10; i++)
	{
		cout << "Result from call " << i << " of chunky() : " << chunky() << endl;
		cout << "Result from call " << i << " of bacon() : " << bacon() << endl;
	}
}

// 4
void arrSize(int arr[])
{
	cout << "Size of arr[] (function call) is : " << sizeof(arr) << endl;
}

void checkSize()
{
	int arr[10]
	cout << "Size of arr[] is : " << sizeof(arr) << endl;
	arrSize(arr);
}

#endif // END Указатели и псевдоними